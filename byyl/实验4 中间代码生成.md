# 实验4 中间代码生成

202011081001 卢皓宇 2022年12月9日

## 实验要求

在词法分析、语法分析和语义分析程序的基础上，将C−−源代码翻译为中间代码。

要求将中间代码输出成**线性结构（三地址代码）**，使用虚拟机小程序（附录B）来测试中间代码的运行结果。  

### 基本要求

1.  对于正确的测试样例，输出可以在虚拟机上运行的中间代码文件。
2.  在程序可以生成正确的中间代码（“正确”是指该中间代码在虚拟机小程序上运行结果正确）的前提下，效率也是最终评分的关键因素。 

### 附加要求

1.   修改前面对C−−源代码的假设2和3，使源代码中： 
     1.   可以出现结构体类型的变量（但不会有结构体变量之间直接赋值）。 
     2.   结构体类型的变量可以作为函数的参数（但函数不会返回结构体类型的值）。 

2.   修改前面对C−−源代码的假设2和3，使源代码中： 
     1.   一维数组类型的变量可以作为函数参数（但函数不会返回一维数组类型的值）。 
     2.   可以出现高维数组类型的变量（但高维数组类型的变量不会作为函数的参数或返回类值）。

## 实验分工

-   卢皓宇：基于样例完善先前的语义分析过程，基于样例2和附加样例2的要求实现代码
-   姜潮涌：确定需要的翻译模式，并基于样例1和附加样例1的要求实现代码
-   段欣然：基于样例协助完善先前的语义分析过程，编写语法树查找函数searchTree()以实现在调用变量时确认其是否为数组变量、是否需要计算偏移量/添加*&等运算符等
-   杜隆清：编写样例，测试代码鲁棒性并提出修改建议

## 实验环境

-   Bison: v3.5.1

-   Flex: v2.6.4

-   虚拟机程序irsim

-   本地程序编写与测试
    -   Windows Subsystem for Linux 2: Ubuntu 20.04 LTS
    -   gcc: 9.4.0
-   云主机测试
    -   BNUCLOUD云主机: Ubuntu 18.04 LTS
    -   gcc: 7.5.0

## 实验设计

### 中间代码的表示

我们选用树形表示中间代码。具体而言，我们采用DFS遍历语法树，也就是对整个代码进行翻译，并将生成中间代码所必须的变量符号存入语法树的对应结点中。

与以链表为代表的线性IR相比较，在我们看来，树形IR的组织依赖于语法树的构造，而不需要单独存储完整的中间代码

-   在通过树形结构对上下文进行组织的过程中，包括声明变量、函数以及运算符等在内的符号已经通过child和bro指针连接起来了
-   在此基础上，我们要做的就是在语法树结点中完善三地址码表示所需要的、在源代码中不会显式书写的**中间变量**、**跳转标签**等
-   这样，语法树就包含了所有构建中间代码所需要的所有必要信息，接下来只要对不同类型的结点制定不同的输出中间代码的规则，然后遍历语法树输出即可

为了方便调试、降低中间代码生成与语法语义分析过程的耦合度，我们选择在完成词法、语法和语义分析，并确认没有任何错误后，再执行中间代码生成过程。

### 一些优化

由于时间紧迫且能力有限，我们最主要的效率优化来自于不为已声明的变量赋别名，这样源代码中重复调用同一变量、立即数时，就不需要另外赋一个中间变量，因而减少了instruction count。

除此之外，我们还对if-else和while的label机制做了一些优化，减少了朴素方式下可能存在的“空label”问题。

## 实验结果

### 样例1

```sh
./complier test1.cmm
```

```assembly
FUNCTION main :
READ n
IF n > #0 GOTO label1
IF n < #0 GOTO label2
WRITE t0
GOTO label3
LABEL label2 :
t1 := #-790459856
WRITE t1
GOTO label3
LABEL label1 :
t2 := #1
WRITE t2
LABEL label3 :
RETURN #0
```

### 样例2

```sh
./compiler test2.cmm
```

```assembly
FUNCTION fact :
PARAM n
IF n == #1 GOTO label1
t0 := n - #1
ARG t0
t1 := CALL fact
t2 := n * t1
RETURN t2
GOTO label2
LABEL label1 :
RETURN n
LABEL label2 :

FUNCTION main :
READ m
IF m > #1 GOTO label3
result := #1

GOTO label4
LABEL label3 :
ARG m
t3 := CALL fact
result := t3

LABEL label4 :
WRITE result
RETURN #0
```

### 附加样例1

```sh
./compiler ext1.cmm
```

```assembly
FUNCTION add :
PARAM temp
t0 := *temp
t1 := temp + #4
t2 := *t1
t3 := t0 + t2
RETURN t3

FUNCTION main :
DEC opobj 8
op := &opobj
*op := #1
t4 := op + #4
*t4 := #2
ARG op
t5 := CALL add
n := t5

WRITE n
RETURN #0
```

### 附加样例2

```sh
./compiler est2.cmm
```

```assembly
FUNCTION add :
PARAM temp
t0 := *temp
t1 := temp + #4
t2 := *t1
t3 := t0 + t2
RETURN t3

FUNCTION main :
DEC op 8
DEC r 8
i := #0
j := #0
LABEL label1 : 
IF i < #2 GOTO label2
 GOTO label3
LABEL label2 : 
LABEL label4 : 
IF j < #2 GOTO label5
 GOTO label6
LABEL label5 : 
t4 := j * #4
t5 := &op + t4
t6 := i + j
*t5 := t6

t7 := j + #1
j := t7

 GOTO label4
LABEL label6 : 
t8 := i * #4
t9 := &r + t8
ARG &op
t10 := CALL add
*t9 := t10

t11 := i * #4
t12 := &r + t11
t13 := *t12
WRITE t13
t14 := i + #1
i := t14

j := #0

 GOTO label1
LABEL label3 : 
RETURN #0
```

## 实验反思

1.   树形IR感觉跟线性IR最大的区别在于，不会有专门的数据结构存储相对更完备的、构造中间代码所需要的信息，因而在生成中间代码时，其实需要更多从上下文（child-bro指针访问）判断翻译模式、计算数组/结构体偏移量等，写起来相对比较麻烦
2.   由于实验进展比较紧张，没有能较好地将生成树形IR与打印树形IR的代码分离成两个独立的过程。但实现效果没有问题，已经存入语法树的中间变量、跳转标签等也会在最后的实验5中得以利用