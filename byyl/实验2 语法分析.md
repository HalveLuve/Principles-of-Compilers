# 实验2 语法分析

202011081001 卢皓宇 2022年10月14日

## 实验要求

基于前面的实验，编写一个程序对使用 C--语言书写的源代码进行语法分析，并打印语法树，实验使用的主要分析工具是Bison，使用C语言完成程序。

-   基本要求
    1.  对程序进行语法分析，输出语法分析结果；
    2.  能够识别多个位置的语法错误。

-   附加要求
    1.  按照正确的缩进格式输出带有行号信息的语法树；
    2.  能够处理简单的语法错误（书中例1.2,1.6,1.8涉及到的错误）。


## 实验分工

-   卢皓宇：程序基本框架的搭建，编写满足基本要求的程序（主要是针对基本要求的两个样例）；修改语法使DefList与StmtList的顺序可以不固定；语法树的实现，并基于样例4进行测试；GitHub项目管理
-   姜潮涌：基于满足基本要求的Flex程序，完成附加要求部分（八进制、十六进制、指数形式浮点数、多行注释等）的正则定义与规则编写
-   段欣然：协助设计完善附加要求部分的正则定义与规则编写，对附加要求部分（尤其是ERRORINT8, ERRORINT16, ERRORFLOAT三个token）进行鲁棒性测试
-   杜隆清：对整个Flex程序（包括基本各项要求、附加各项要求等）设计样例进行鲁棒性测试，并协助进行debug工作

## 实验环境

-   Bison: v3.5.1

-   Flex: v2.6.4

-   本地程序编写与测试
    -   Windows Subsystem for Linux 2: Ubuntu 20.04 LTS
    -   gcc: 9.4.0
-   云主机测试
    -   BNUCLOUD云主机: Ubuntu 18.04 LTS
    -   gcc: 7.5.0

## 实验设计

### 程序功能

1.   **对程序进行语法分析，输出语法分析结果**。通过针对各种错误定义产生式、编写错误信息
2.   **能够识别多个位置的语法错误**。原生的yyerror()在遇到错误时就终止程序运行，所以简单来说思路就是使原生的yyerror()失效，使用自定义的报错输出函数；这样也可以实现报错信息的自定义输出
3.   **按照正确的缩进格式输出带有行号信息的语法树**。采用孩子-兄弟表示法，定义union用于存储字符信息或整形数据或浮点型数据，并定义相关函数以供语法分析过程中构建语法树
4.   **能够处理简单的语法错误**。对八进制、十六进制和浮点数的报错进行一定修正

### 功能实现

1.   因为语法错误难以穷举，且设计不当比较容易出现shift/reduce conflicts，所以我们仅针对样例中涉及的情况设计对应的产生式。具体来说

     -   只有else而缺少if（test1.cmm）

         ```c
         else i = 4;
         ```

         else后面的i = 4是一个Dec (VarDec ASSIGNOP Exp) -> DecList，而else不应该单独出现在其前面（否则与if一同出现的话会被归约到Stmt -> IF LP Exp RP Stmt ELSE Stmt）。故我们设计产生式

         ```c
         Def: ...
             | error DecList SEMI {
             	char msg[100];
         		sprintf(msg, "Syntax error.");
         		myerror(msg);
         	}
         	| ...
             ;
         ```

         经debug测试可以成功匹配并输出

     -   赋值语句缺失（test1.cmm）

         ```c
         i = ;
         ```

         该语句可被归约：Exp ASSIGNOP error -> Exp; Exp SEMI -> Stmt。所以设计如下

         ```c
         Exp : ...
         	| Exp ASSIGNOP error{ 
         		char msg[100];
                 sprintf(msg, "Syntax error."); // ASSIGNOP not in front of Exp
         		myerror(msg);
         	}
         	| ...
             ;
         ```

     -   未定义的token（test3.cmm）

         ```c
         %666
         ```

         注意这里指的是前面的'%'符号。这是我们在词法分析部分实验中没有定义的符号，所以可以直接通过匹配yf.l中定义的token来输出错误。

         ```c
         . {
         	errors++;
         	printf("Error Type A at line %d, char %d: Mysterious character: '%s'\n", yylineno, chars, yytext);
         	chars += yyleng;
         	}
         ```

     -   缺分号（test3.cmm）

         ```c
         %666
         ```

         注意这里指后面的666数字。我们会首先将其匹配为INT -> Exp，然后下一个token是IF，不能接在Exp后面。所以我们设计了Exp error

         ```c
         Stmt: ...
             | Exp error {
                     char msg[100];
                     sprintf(msg, "error: Missing \";\"");
                     myerror(msg);
                 }
         	| ...
             ;
         ```

     -   数组变量缺后括号（test3.cmm）

         ```c
         float p[i = 2.52;
         ```

         这个问题本身并不难解决：VarDec定义了变量声明的产生式，我们只需要加入缺右中括号、用error代替的产生式即可

         ```c
         VarDec: ...
             | VarDec LB ID error {
                 char msg[100];
                 sprintf(msg, "Missing \"]\".");
         		myerror(msg);
             }
         	| ...
             ;
         ```

         但由于书上所规定的C--文法只允许Stmt/StmtList接在Def/DefList后面，而不允许在StmtList后面写Def/DefList。所以到此为止，test3.cmm会报5个错而不是样例输出中的4个错——多了一个StmtList后面不能有Def/DefList的错。

         要让此处的错误被匹配且不另外报别的错，我们需要对文法做一定程度的修改，**将Def和Stmt归约到一个Mid的中间状态，并将所有的DefList和StmtList都替换为Mid**。其代价就是语法树结构会有一定差异，但是我们认为在理解语法分析的原理基础上，这个操作无伤大雅（只是或许与后续实验改动会有不兼容，到时候再回滚吧）

         ```c
         CompSt : LC Mid RC {
                 $$ = insNode($1, "CompSt", @1.first_line, NON_TERMINAL);
                 $1->bro = $2;
                 $2->bro = $3;
             }
             ;
             
         Mid : Def Mid {
                 $$ = insNode($1, "Mid", @1.first_line, NON_TERMINAL);
                 $1->bro = $2;
         	}
         	| Stmt Mid{
                 $$ = insNode($1, "Mid", @1.first_line, NON_TERMINAL);
                 $1->bro = $2;
         	}
         	| {
                 $$ = insNode(NULL, "Mid", yylineno, NON_TERMINAL);
         	}
         	;
         ```


2.   重载yyerror()并将其函数主体置空，然后编写myerror()函数并在错误处调用

     ```c
     %{
         ...
         void yyerror(char*);
         void myerror(char*);
         ...
     %}
     %{
         void yyerror(char *msg) {
         // errors++;
         // fprintf(stderr, "Error type B at Line %d: %s because %s\n", yylineno, msg, yytext);
     }
     
     void myerror(char *msg) {
         fprintf(stderr, "Error type B at Line %d: %s\n", last_row, msg); // B
     	errors++;
     }
     %}
     ```

     

## 实验结果

使用实验指导中的test.cmm测试命令如下

```shell
flex yf.l
bison -d syntax.y
gcc syntax.tab.c SyntaxTree.c -lfl -ly -o parser
./parser test.cmm
```

输出结果如下

```shell
TYPE at line 1, char 1: int
ID at line 1, char 5: main
BRACKET at line 1, char 9: (
BRACKET at line 1, char 10: )
BRACKET at line 1, char 11: {
TYPE at line 2, char 5: float
ID at line 2, char 11: f
ASSIGNOP at line 2, char 13: =
FLOAT at line 2, char 15: 2e-5
SEMI at line 2, char 19: ;
TYPE at line 3, char 5: int
ID at line 3, char 9: n_num
ASSIGNOP at line 3, char 15: =
INT data at line 3, char 17: 30
SEMI at line 3, char 19: ;
KEYWORD at line 4, char 5: if
BRACKET at line 4, char 7: (
ID at line 4, char 8: n
RELOP at line 4, char 10: >
FLOAT at line 4, char 12: 0.15
BRACKET at line 4, char 16: )
BRACKET at line 4, char 17: {
ID at line 5, char 9: printf
BRACKET at line 5, char 15: (
ERROR Type A at line 5, char 16: Mysterious character: '"'
ERROR Type A at line 5, char 17: Mysterious character: '"'
BRACKET at line 5, char 18: )
SEMI at line 5, char 19: ;
BRACKET at line 6, char 5: }
KEYWORD at line 6, char 6: else
BRACKET at line 6, char 10: {
ID at line 7, char 9: _f2
ASSIGNOP at line 7, char 13: =
ID at line 7, char 15: _f
START at line 7, char 18: *
FLOAT at line 7, char 20: 0.15
SEMI at line 7, char 24: ;
RELOP at line 8, char 9: <
RELOP at line 8, char 11: >
RELOP at line 8, char 13: ==
ERROR Type A at line 9, char 9: Mysterious character: '#'
ERROR Type A at line 9, char 11: Mysterious character: '%'
AND at line 9, char 13: &&
DIV at line 10, char 9: /
NOTE at line 10, char 13: //note
DOT at line 11, char 9: .
OR at line 11, char 11: ||
COMMA at line 11, char 14: ,
BRACKET at line 12, char 5: }
KEYWORD at line 13, char 5: return
INT data at line 13, char 12: 0
SEMI at line 13, char 13: ;
BRACKET at line 14, char 1: }
```

**注**：实验指导文档中的期望输出应该有拼写错误

-   ';'应为<u>SEMI</u>
-   "Error Type A"后面应该是"<u>Mysterious</u> character"
-   Illgal octal/hexadecimal/float number -> Illegal octal/hexadecimal/float number

使用实验指导中的test2.cmm测试命令如下

```sh
./scanner test2.cmm
```

输出如下

```sh
INT8 data at line 1, char 1: 0547
Error Type A at line 1, char 6: Illegal octal number: '089'
INT16 data at line 1, char 10: 0x5c4ad
INT16 data at line 1, char 18: 0X345
INT16 data at line 1, char 24: 0X1D7E
Error Type A at line 1, char 31: Illegal hexadecimal number: '0x4m4'
FLOAT at line 2, char 1: 1.23
FLOAT at line 2, char 6: 1.3e0
FLOAT at line 2, char 12: 13.5e9
FLOAT at line 2, char 19: 2.e-23
FLOAT at line 2, char 26: 3.
FLOAT at line 2, char 29: .08
Error Type A at line 2, char 33: Illegal float number: '2er'
Error Type A at line 2, char 37: Illegal float number: '15e'
Error Type A at line 2, char 41: Illegal float number: '1e2.5'
NOTE at line 3, char 1: // note1
NOTE at line 6, char 1: /* this
is a long long comment
*/
ID at line 7, char 1: h
ASSIGNOP at line 7, char 3: =
INT data at line 7, char 5: 5
DIV at line 7, char 7: /
INT data at line 7, char 9: 2
NOTE at line 7, char 11: // note2
```

## 实验反思

1.   文法中token的正则表达式确定？

     见上功能实现1部分

2.   实验中如何忽略空白字符？

     使用WHITESPACE (" "+), TAB \t匹配空格和缩进，在规则部分规定不显示任何内容，而只更新chars计数

3.   实验中如何正确获得token的字符数？

     -   使用flex内置提供的变量yyleng（即当前匹配语素的长度/字符数）。每次匹配到某一个语素，字符计数变量chars就加上yyleng
     -   **缩进\t**比较特殊，匹配到的yyleng是1，但通常的编辑器会将缩进显示为4个空白字符，所以token TAB的字符数我们没有采用yyleng，而是规定为4

4.   A few more things...

     -   实验中编写的多数token的正则如果去掉双引号，Flex不会报错；但是部分token，比如所有括号、除号、逻辑或等，如果没有加双引号就会报错。

         这里双引号应该是起到转义的作用，如单行注释 "//".* 等价于\/\/.*

     -   **Flex的规则部分（rules）应该是从上到下顺序执行的**。我们在编写测试的过程中发现，如果将ID这个token的"pattern {action}"语句放在相对靠前的位置，而将IF, ELSE, WHILE, RETURN等其他文字token放在相对靠后的位置，会导致if, else, while, return这类文字形式的关键字被ID匹配（本来从正则上讲，这些也是ID的正则所能匹配的子集），而不会被IF, ELSE, WHILE, RETURN匹配；而将IF, ELSE, WHILE, RETURN等token的规则语句放在ID前面，就可以规避这样的问题：即它们按顺序先被IF, ELSE, WHILE, RETURN等token匹配了，而不会被ID匹配。