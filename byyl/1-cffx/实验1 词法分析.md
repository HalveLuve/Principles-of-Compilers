# 实验1 词法分析

## 实验要求

编写一个程序对使用 C--语言书写的源代码进行词法分析，并打印分析结果。学习词法分析工具 Flex的使用方法，并使用 C 语言完成程序。

-   基本要求
    1.  输出C--文法规定的基本词法分析结果（27种token）；
    2.  输出未定义的标识符；
    3.  识别单行注释。

-   附加要求
    1.  识别八进制和十六进制数；
    2.  识别指数形式浮点数；
    3.  识别多行注释。


## 实验分工

卢皓宇：Full-stack

## 实验环境

-   Flex: v2.6.4

-   本地程序编写与测试
    -   Windows Subsystem for Linux 2: Ubuntu 20.04 LTS
    -   gcc: 9.4.0
-   云主机测试
    -   BNUCLOUD云主机: Ubuntu 18.04 LTS
    -   gcc: 7.5.0

## 实验设计

### 程序功能

1.   **输出C--文法规定的基本词法分析结果**。这个部分我们同时参考了实验指导书上的27种token、测试样例的期望输出以及实现过程中的一些实际问题，最终一共定义了32种token；
2.   **输出未定义的标识符**。我们直接参考测试样例的期望输出编写，输出对于功能1中定义的token失配的字符及位置；
3.   **识别单行注释**。本质上是功能1的一部分；
4.   **指示以上所有语素所在的位置（行数、字符数）**。基本上是基于yylineno和自定义字符计数变量chars实现。

### 功能实现

1.   功能1~3利用正则表达式匹配。所以该功能实现重点在**正则表达式编写**上：既要保证能够将所有已定义且词法正确的语素匹配出来，还要保证彼此的匹配不会互相干扰。

     ```c
     %option yylineno
     DIGIT [0-9]
     INT [0-9]{DIGIT}*
     PLUS \+
     MINUS -
     STAR \*
     ASSIGNOP = 
     RELOP ==|<|>|>=|<=|!=
     INTT ({PLUS}|{MINUS})?{INT}
     FLOAT {INT}(.{INTT})
     LETTER [a-zA-Z]
     TYPE void|int|float|double|char
     IF if
     ELSE else
     WHILE while
     RETURN return
     STRUCT struct
     AND &&
     OR "||"
     DOT \.
     NOT !
     DIV "/"
     NOTE "//".*
     LP "("
     RP ")"
     LB "["
     RB "]"
     LC "{"
     RC "}"
     SEMI ;
     ID ({LETTER}|_)({LETTER}|_|{DIGIT})*
     WHITESPACE (" "+)
     TAB \t
     NEWLINE \n
     COMMA ,
     %{
     int chars = 1;
     %}
     ```

     其中

     -   选项%option yylineno记录符号所在行号，不必写numLines++之类的语句，可以相对简化代码；
     -   DIGIT, LETTER, WHITESPACE, TAB, NEWLINE等属性没有定义显示的**规则**：因为它们要么是为了简化更复杂的token的正则式而构建的“中间表达式”，要么是没有显示的意义；
     -   定义部分的变量int chars = 1即记录当前的字符数（考虑空格、缩进）用，下面功能4的实现会详细介绍；

2.   功能4需要在每一次匹配到换行符时，将用户自定义变量chars（记录字符数）重置为1；此后每一次匹配到一个语素，就让<u>chars变量 + 该语素长度 (yyleng)</u>实现更新。

     下面是**规则**部分，匹配到NEWLINE (\n)时就将chars置为1；匹配到其他token就chars += yyleng（除了TAB (\t)，不同于日常使用会使代码后移4个字符，其yyleng仍为1，所以我们规定chars += 4）。

     ```c
     {NEWLINE} {chars = 1;}
     {COMMA} {printf("COMMA at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {DOT} {printf("DOT at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {NOT} {printf("NOT at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     ({INT}|{INTT}) {printf("INT data at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {PLUS} {printf("PLUS at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {ASSIGNOP} {printf("ASSIGNOP at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {RELOP} {printf("RELOP at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {TYPE} {printf("TYPE at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     ({IF}|{ELSE}|{WHILE}|{RETURN}) {printf("KEYWORD at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {STRUCT} {printf("STRUCT at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {AND} {printf("AND at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {OR} {printf("OR at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {STAR} {printf("START at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {MINUS} {printf("MINUS at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {DIV} {printf("DIV at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {NOTE} {printf("NOTE at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     ({LP}|{RP}|{LB}|{RB}|{LC}|{RC}) {printf("BRACKET at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {SEMI} {printf("SEMI at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {FLOAT} {printf("FLOAT at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;}
     {ID} {printf("ID at line %d, char %d: %s\n", yylineno, chars, yytext); chars += yyleng;} 
     {WHITESPACE} {chars += yyleng;}
     {TAB} {chars += 4;}
     . {printf("ERROR Type A at line %d, char %d: Mysterious character: '%s'\n", yylineno, chars, yytext); chars += yyleng;}
     ```

​		用户自定义部分的main函数基本参考实验指导文档，故不赘述

## 实验结果

使用实验指导中的test.cmm测试命令如下

```shell
flex cf.l
gcc lex.yy.c -lfl -o scanner
./scanner test.cmm
```

输出结果如下

```shell
TYPE at line 1, char 1: int
ID at line 1, char 5: main
BRACKET at line 1, char 9: (
BRACKET at line 1, char 10: )
BRACKET at line 1, char 11: {
TYPE at line 2, char 5: float
ID at line 2, char 11: f
ASSIGNOP at line 2, char 13: =
FLOAT at line 2, char 15: 2.5
SEMI at line 2, char 18: ;
TYPE at line 3, char 5: int
ID at line 3, char 9: n_num
ASSIGNOP at line 3, char 15: =
INT data at line 3, char 17: 30
SEMI at line 3, char 19: ;
KEYWORD at line 4, char 5: if
BRACKET at line 4, char 7: (
ID at line 4, char 8: n
RELOP at line 4, char 10: >
FLOAT at line 4, char 12: 0.15
BRACKET at line 4, char 16: )
BRACKET at line 4, char 17: {
ID at line 5, char 9: printf
BRACKET at line 5, char 15: (
ERROR Type A at line 5, char 16: Mysterious character: '"'
ERROR Type A at line 5, char 17: Mysterious character: '"'
BRACKET at line 5, char 18: )
SEMI at line 5, char 19: ;
BRACKET at line 6, char 5: }
KEYWORD at line 6, char 6: else
BRACKET at line 6, char 10: {
ID at line 7, char 9: _f2
ASSIGNOP at line 7, char 13: =
ID at line 7, char 15: _f
START at line 7, char 18: *
FLOAT at line 7, char 20: 0.15
SEMI at line 7, char 24: ;
RELOP at line 8, char 9: <
RELOP at line 8, char 11: >
RELOP at line 8, char 13: ==
ERROR Type A at line 9, char 9: Mysterious character: '#'
ERROR Type A at line 9, char 11: Mysterious character: '%'
AND at line 9, char 13: &&
DIV at line 10, char 9: /
NOTE at line 10, char 13: //note
BRACKET at line 11, char 5: }
KEYWORD at line 12, char 5: return
INT data at line 12, char 12: 0
SEMI at line 12, char 13: ;
BRACKET at line 13, char 1: }
```

**注**：实验指导文档中的期望输出应该有拼写错误

-   ';'应为<u>SEMI</u>
-   "Error Type A"后面应该是"<u>Mysterious</u> character"

## 实验反思

1.   文法中token的正则表达式确定？

     见上功能实现1部分

2.   实验中如何忽略空白字符？

     使用WHITESPACE (" "+), TAB \t匹配空格和缩进，在规则部分规定不显示任何内容，而只更新chars计数

3.   实验中如何如何正确获得token的字符数？

     -   使用flex内置提供的变量yyleng（即当前匹配语素的长度/字符数）。每次匹配到某一个语素，字符计数变量chars就加上yyleng
     -   **缩进\t**比较特殊，匹配到的yyleng是1，但通常的编辑器会将缩进显示为4个空白字符，所以token TAB的字符数我们没有采用yyleng，而是规定为4

4.   A few more things...

     -   关于双引号：正则表达式的书写规则中，""既不是非打印字符，也不是特殊字符、限定符等。实验中编写的多数token的正则如果去掉双引号，Flex不会报错；但是部分token，比如所有括号、除号、逻辑或等，如果没有加双引号就会报错。

         对于这个问题，我们的观点是：**双引号的问题应该与正则本身的书写规则无关，而与Flex本身的语法特性有关**。毕竟“裸”的正则对双引号没有要求，而在编写Flex文件的时候(), [], \{\}都有一定语法意义，可能需要双引号去标识区别一下。

     -   **Flex的规则部分（rules）应该是从上到下顺序执行的**。我们在编写测试的过程中发现，如果将ID这个token的"pattern {action}"语句放在相对靠前的位置，而将IF, ELSE, WHILE, RETURN等其他文字token放在相对靠后的位置，会导致if, else, while, return这类文字形式的关键字被ID匹配（本来从正则上讲，这些也是ID的正则所能匹配的子集），而不会被IF, ELSE, WHILE, RETURN匹配；而将IF, ELSE, WHILE, RETURN等token的规则语句放在ID前面，就可以规避这样的问题：即它们按顺序先被IF, ELSE, WHILE, RETURN等token匹配了，而不会被ID匹配。